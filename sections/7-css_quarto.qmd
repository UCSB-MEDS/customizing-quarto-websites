---
format: revealjs
---

##  {#css-quarto data-menu-title="CSS + Quarto" background="#053660"}

<div class="page-center">
<div class="custom-subtitle">`r fontawesome::fa("question", fill = "#d2e3f3", a11y = "sem")` Okay, but what about Quarto?</div>
</div>

---

##  {#styles.css data-menu-title="Quarto comes with `styles.css`"}

[When you create a new Quarto site, it automatically creates a `styles.css` file]{.slide-title-smallest}

<hr>

:::: {.columns}
::: {.column width="50%"}
<br>

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/quarto_files.png")
```

:::
::: {.column width="50%"}
<br>

::: {.body-text}
We can write our CSS rules in `styles.css`, *but alternatively*, we can write them directly in our `styles.scss` file ***(remember, you can write CSS in a `.scss` file but you can't write Sass in a `.css` file)***. 
:::

::: {.body-text}
You can delete `styles.css` if you don't plan to use it, or leave it be (it's easy to create a new one using the `touch` command in your terminal).
:::
:::
::::

---

##  {#scss-div data-menu-title="SCSS rules divider"}

[Create a section for defining CSS rules in `styles.scss`]{.slide-title}

<hr>

::: {.body-text .topbr}
To start defining CSS rules in `styles.scss` you first need to add the `/*-- scss:rules --*/` region decorator beneath your Sass variables section:
:::

```{css}
#| eval: false
#| echo: true
#| code-line-numbers: "11"

/*-- scss:defaults --*/
// Fonts
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@300&display=swap');

// Colors
$light-sage-green: #D1D9CE;
$dark-sage-green: #98A08D;

// additional Sass variables omitted for brevity

/*-- scss:rules --*/
```

::: {.body-text .topbr}
Next, we'll walk through some examples of how to modify your site with your own CSS rules.
:::

---

##  {#determine-element-to-style data-menu-title="Determine element(s) to style"}

[Determine which element you want to style]{.slide-title-smallest}

<hr>

::: {.body-text .topbr}
Let's say I want to similarly style (add spacing between each letter, increase the font weight, make a dark gray color) the following text on my website:
:::

:::: {.columns}

::: {.column width="33%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/index-font.png")
```

::: {.caption-text .center-text .gray-text .topbr}
On my landing page, I want to style my name, "samantha csik", and the three section headers, "hi there!", "education", and "experience"
:::

:::

::: {.column width="33%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/about-font.png")
```

::: {.caption-text .center-text .gray-text .topbr}
On my about page, I want to style the top header, "about"
:::

:::

::: {.column width="33%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/resources-font.png")
```

::: {.caption-text .center-text .gray-text .topbr}
On my resources page, I want to style the top header, "resources"
:::

:::

::::

---

##  {#dont-know-element data-menu-title="Don't know element?"}

[But what if I don't know what HTML element type this is? Inspect!]{.slide-title-smallest}

<hr>

:::: {.columns}
::: {.column width="50%"}
<br>

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/inspect.gif")
```

:::
::: {.column width="50%"}
<br>

::: {.caption-text .topbr}
Using the **Inspect** tool is a great way to get a better sense of how CSS is used to modify particular HTML elements (this works with any web page, and *also* your locally hosted website preview).
:::

::: {.caption-text .topbr}
In your website preview, **right click on an element of interest** (in this case, let's start with my name, "samantha csik") and **choose Inspect** to pull up the underlying HTML & CSS files.
:::

::: {.caption-text .topbr}
Hovering your mouse over different lines of HTML highlights the corresponding element on your webpage.
:::
:::
::::

---

##  {#inspect-name data-menu-title="Inspect landing page name"}

::: {.large-body-text .center-text}
My name is an `<h1>` element
:::

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/inspect-name.png")
```

::: {.caption-text .gray-text .center-text}
**Note:** This `<h1>` element also has a class `title` -- more on that in a minute.
:::

---

##  {#inspect-landing-page-sections data-menu-title="Inspect landing page sections"}

::: {.large-body-text .center-text}
My landing page section, "education" (as well as "hi there!" and "experience") are `<h3>` elements
:::

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/inspect-education.png")
```

---

##  {#inspect-about data-menu-title="Inspect about page"}

::: {.large-body-text .center-text}
My about page title (as well as my resource page title) are `<h1>` elements
:::

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/inspect-about.png")
```

---

##  {#write-grouping-selector data-menu-title="Write a CSS grouping selector"}

[Write a CSS grouping selector to style `<h1>` and `<h3>` elements]{.slide-title-smallest}

<hr>

::: {.panel-tabset}

## `styles.scss` file

::: {.body-text .topbr .bottombr}
Here, we have a grouping selector that targets *all* `<h1>` and `<h3>` elements -- it increases both the spacing between each letter and the font weight (makes it bolder), and it colors those header levels gray (reminder: I created a Sass variable: `$gray: #64605f;`).
:::

```{css}
#| eval: false
#| echo: true
/*-- scss:rules --*/

h1, h3 {
  letter-spacing: 5px;
  font-weight: 700;
  color: $gray;
}
```

## Output

:::: {.columns}
::: {.column width="50%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/without-header-styling.png")
```

::: {.caption-text .gray-text .center-text .topbr}
No CSS styling on `h1` and `h3` headers
:::
:::
::: {.column width="50%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/with-header-styling.png")
```

::: {.caption-text .gray-text .center-text .topbr}
With CSS styling on `h1` and `h3` headers
:::
:::
::::

## Notes

::: {.body-text}
**{{< fa angle-right >}}** I don't need to make any changes to the HTML (in `index.qmd`, `about.qmd`, and `resources.qmd` since this grouping selector targets *all* `<h1>` and `<h3>` elements across my site. If an element on any of my pages has either of those tags, it will get styled with the declarations included in our CSS rule.
:::

:::

---

##  {#title-class data-menu-title="'title' class"}

[What's with that `title` class selector?]{.slide-title}

<hr>

::: {.caption-text .topbr}
Note how the page headers ("samantha csik" on the landing page, and "about" and "resources" on those respective pages), which all happen to be `<h1>` elements, are also of class, `title`.
:::

::: {.caption-text .topbr}
The Quarto framework has defined a class selector called `.title` and applied that class to the above elements. We can modify it however we'd like. For example, let's turn text elements of class `title` the color red:
:::

::: {.panel-tabset}

## `styles.scss` file
```{css}
#| eval: false
#| echo: true
/*-- scss:rules --*/

h1, h3 {
  letter-spacing: 5px;
  font-weight: 700;
  color: $gray;
}

.title {
  color: red;
}
```

## Output

:::: {.columns}
::: {.column width="33%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/red-name.png")
```

:::
::: {.column width="33%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/red-about.png")
```

:::
::: {.column width="33%"}

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "100%" 
knitr::include_graphics("images/red-resources.png")
```

:::
::::

## Notes

<div class="body-text">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` In this case, I don't need to make any changes to the HTML (in `index.qmd`, `about.qmd`, and `resources.qmd`) since those `<h1>` elements are *already* assigned the class, `title`.</div>

:::

---

##  {#title-class2 data-menu-title=""}

[Okay, but what about `<h1>` elements that are not of class `title`?]{.slide-title-smallest}

<hr>

::: {.body-text .topbr}
Let's write a couple of other elements that *are not* of `class="title"` to see what happens. I'll do this on my *about* page:
:::

::: {.panel-tabset}

## `about.qmd` file

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "5-11"
---
title: "about"
---

<h1>this is an `<h1>` element</h1> # alternatively, you can write <h1> elements using markdown (`# this is an `<h1>` element`)

<h1 class="title">this is an `<h1>` element of class `title`</h1>

<p>this is a `<p>` element</p>

<p class="title">this is a `<p>` element of class `title`</p>
```

## Output

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "60%" 
knitr::include_graphics("images/h1-title.png")
```

## Notes

::: {.caption-text .topbr}
**{{< fa angle-right >}}** You can add elements on your web pages using either Markdown syntax (e.g. use `# text here` to denote an `<h1>` element) *or* use HTML tags (e.g. use `<h1>text here</h1>`). I tend to use a mix of both Markdown syntax and HTML tags.
:::

::: {.caption-text .topbr}
**{{< fa angle-right >}}** Class selectors allow us to customize exactly how CSS rules apply to particular elements. In this example, only `<h1>` elements that are of class `title` are colored red. Any `<h1>` elements that are not of class `title` are styled according to our `h1, h3 {}` element selector.
:::

::: {.caption-text .topbr}
**{{< fa angle-right >}}** We can apply the `title` class to any text element. In this example, we apply it both to an `<h1>` element and a `<p>` element.
:::

:::

---

##  {#write-own-class-selector data-menu-title="Write your own class selector"}

[Write your own class selector]{.slide-title}

<hr>

::: {.panel-tabset}

## `styles.scss` file

::: {.body-text .bottombr}
Let's create a class named `.custom-subtitle` that styles text in the following ways: increases font size, italicizes it, and colors it purple. We can then add an element to our **resources** page and apply our new class selector:
:::

```{css}
#| eval: false
#| echo: true
#| code-line-numbers: "13-17"
/*-- scss:rules --*/

h1, h3 {
  letter-spacing: 5px;
  font-weight: 700;
  color: $gray;
}

.title {
  color: red;
}

.custom-subtitle {
  font-size: 22px;
  font-style: italic;
  color: $purple;
}
```

## `resources.qmd` file

::: {.body-text .bottombr}
Here, I'm creating two paragraphs -- one that is styled with `.custom-subtitle` and one that is not.
:::

::: {.body-text .bottombr}
What happens if you create your custom subtitle using an `<h1>` tag instead of `<p>`? Why do you think this happens?
:::

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "5,7"

---
title: "resources"
---

<p class="custom-subtitle">Here is my custom subtitle.</p>

<p>And here is some normal text beneath it.</p>
```

## Output

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "60%" 
knitr::include_graphics("images/custom-subtitle.png")
```

## Notes

<div class="body-text topbr">`r fontawesome::fa("angle-right", fill = "#05859B", a11y = "sem")` Remember, class selectors take the form `.selector-name {}`</div>

:::

---

##  {#apply-two-class-selectors data-menu-title="Apply two class selectors"}

[Apply a second class selector to our text styled as a `custom-subtitle`]{.slide-title-smaller}

<hr>

::: {.panel-tabset}

## `styles.scss` file

::: {.caption-text .bottombr}
Let's say we want the option to add a bit of extra space beneath this particular custom subtitle before the element is rendered -- but maybe we don't *always* want that extra space beneath *every* custom subtitle. If we were to add a declaration that increases `margin-bottom` directly to our `.custom-subtitle` class selector, all elements of class `custom-subtitle` would have that extra space.
:::

::: {.caption-text .bottombr}
One solution, then, is to create a new class selector (we'll call it `.bottombr`, for "bottom break") that we can specifically apply to our custom subtitle on the **resources** page.
:::

```{css}
#| eval: false
#| echo: true
#| code-line-numbers: "10-12"
/*-- scss:rules --*/

/* Additional rules/electors omitted for brevity */

.custom-subtitle {
  font-size: 22px;
  font-style: italic;
  color: $purple;
}

.bottombr {
  margin-bottom: 3em;
}
```

## `resources.qmd` file

::: {.body-text .bottombr}
Here, we add our `bottombr` class selector within the `""` after `custom-subtitle` and a space.
:::

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "5"
---
title: "resources"
---

<p class="custom-subtitle bottombr">Here is my custom subtitle.</p>

<p>And here is some normal text beneath it.</p>
```

## Output

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "60%" 
knitr::include_graphics("images/bottombr.png")
```

## Notes

::: {.body-text .topbr}
**{{< fa angle-right >}}** Remember, HTML elements can have more than one class, e.g. `<p class="class1 class2 etc">`
:::

:::

---

##  {#quarto-syntax data-menu-title="Quarto Syntax"}

[Quarto also provides its [own syntax](https://quarto.org/docs/authoring/markdown-basics.html#divs-and-spans) for applying classes to elements]{.slide-title-smallest}

<hr>

::: {.body-text .bottombr}
You can create both **divs (block-level regions of content)** and **spans (inline content)** using Quarto's syntax. For example:
:::

:::: {.columns}

::: {.column width="50%"}
::: {.body-text .center-text}
**Divs**
:::

```{.md}
# Quarto syntax
::: {.my-selector}
Some element (e.g. text) to style
:::
  
# HTML syntax
<div class="my-selector">
  Some element (e.g. text) to style
</div>
```
:::

::: {.column width="50%"}
::: {.body-text .center-text}
**Spans**
:::

```{.md}
# Quarto syntax
Some text with just [this section]{.my-selector} styled

# HTML syntax
<p>Some text with just <span class="my-selector">this section</span> styled</p>
```
:::

::::

---

##  {#mix-match data-menu-title="Mix & match styles"}

[You can mix and match syntaxes in `.qmd` files]{.slide-title}

<hr>

::: {.body-text .bottombr}
I tend to use a mix of both approaches (HTML & Quarto syntax). For example:
:::

::: {.panel-tabset}

## `resources.qmd` file

```{r}
#| eval: false
#| echo: true

---
title: "resources"
---

<p class="custom-subtitle">Here is my custom subtitle.</p>

<p>And here is some normal text beneath it.</p>

[Here is another custom subtitle written with Quarto syntax]{.custom-subtitle}

Also note that I do not need to wrap this text in the `<p>` tag in order for it to render as normal text. `.qmd` files allow us to seamlessly blend markdown syntax with HTML.
```

## Output

```{r}
#| eval: true 
#| echo: false
#| fig-align: "center"
#| out-width: "60%" 
knitr::include_graphics("images/quarto-css-syntax.png")
```

## Notes

::: {.caption-text}
**{{< fa angle-right >}}** You'll notice the `[]{}` and `::: {} :::` syntax throughout Quarto's documentation, and also if you explore the source code of other Quarto websites/presentations/etc. You don't *need* to use it, but it helps to know what it is when you see it!
:::

:::

